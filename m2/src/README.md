# 流程

1. 输入事件：
    1.1 First   首笔（开始点，结束点）
    1.2 New     新的一笔（前一笔的结束点也是新笔的开始点）
    1.3 Update  笔延伸事件（当前笔的结束点）

    事件处理流程
    1.1 First事件，将两个端点压入Pens队列, 端点数量不够，所以不做进一步处理
    1.2 Update事件，弹出最后的笔，压入新的笔结束点，由于笔还没有确定结束，所以不做进一步处理
    1.3 New事件，新笔产生了，压入前笔的结束点，处理特征序列，判断线段结束

2. 输出事件
    2.1 First(from, to)
    2.2 New(to)
    2.3 New2(from, to)
    2.4 Update(to)

3. 基于特征序列的线段划分标准方法主要步骤:
    先根据线段方向，找出特征序列，然后对特征序列进行标准化，寻找标准特征序列的分型，
    然后判断分型第1,2元素间是否有缺口，分为第一种破坏和第二种破坏；
    第一种破坏比较简单直接，当即可断定线段结束；
    第二种破坏则需要寻找反向特征序列的分型来进行确认，如果没有出现反向特征序列分型就新高新低，则仍为原线段的延续。

4. 特征序列的处理
    2.1 特征序列标准化，这里有个合并方向的问题
    2.2 检测有没有分型
    2.2.1 如果有分型，转线段处理
    2.2.2 没有分型，处理结束
    2.3 在特征序列判断前要先判断第一个线段，如果有了，触发First(Fronm, to)
    2.4 新笔来了之后，根据笔与线段方向，触发Update(to)

5. 线段处理
    3.1 有分型之后，判断属于情况一、二
    3.2 情况一，可以直接判断当前线段结束
    具体处理：
    3.2.1 把这个端点压入线段列表，触发事件New(Point,pen_lists)
    3.2.2 除线段端点，前面的端点清除，其实当触发事件的时候，其实队列里有很多笔
    3.3 情况二，不能直接判断线段结束，当下一分型成立才能判断线段结束,触发New2(Point, pen_list_1, Point, pen_list_2)
    3.3.1 需要特征序列二，保存反向笔序列，判断第二特征序列的分型
    3.3.1.1 如果出现了分型（第二特征序列），可以判断两个线段的结束，这里有个问题就是什么时候停止第二特征序列的判断

6. 一些标准：
    4.1 前3笔重叠才算线段，注意，不一定最后一个线段是最高或者最低

